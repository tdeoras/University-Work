{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {
    "colab_type": "text",
    "id": "P9jhkSLIJKOl"
   },
   "source": [
    "<center>\n",
    "  <h1> CSCI-P556 Applied Machine Learning</h1>\n",
    "  <h1> CSCI-P556</h1>\n",
    "  <h1> Assignment 0 </h1>\n",
    "</center>\n",
    "---\n",
    "\n",
    "\n",
    "\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "colab_type": "text",
    "id": "JYtDB9S1J0Wt"
   },
   "source": [
    "## Instructions\n",
    "1. Please read the questions carefully and give your responses in the correct place.\n",
    "2. Do not change the contents of the notebook except when adding your reponses or where it is explicitly mentioned.\n",
    "3. Whenever you are asked to write a function and the argument names are mentioned in the question, you have to assume that while testing these arguments will be defined elsewhere in the notebook. \n",
    "3. You are allowed to define test arguments of the same name in the respective code block in order to test your functions.\n",
    "4. If you have been asked to print or plot something, you are supposed to print/plot it and not just provide a function. This is grad school, we expect the plots to be labeled.\n",
    "5. You should save your notebook along with the outputs and submit it\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {
    "colab": {},
    "colab_type": "code",
    "id": "UNM9lalxKEHe"
   },
   "outputs": [],
   "source": [
    "# For this assignment you'll need to import the following libraries:\n",
    "import numpy as np\n",
    "import pandas as pd\n",
    "import matplotlib.pyplot as plt"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "colab_type": "text",
    "id": "zTxEzCY4KOHu"
   },
   "source": [
    "## Question 1 (5 points)\n",
    "\n",
    "Consider a 4x4 numpy array as shown\n",
    "$$\\begin{bmatrix}1 & 2 & 3 & 4\\\\5 & 6 & 7 & 8\\\\9 & 10 & 11 & 12\\\\13 & 14 & 15 & 16\\end{bmatrix}$$\n",
    "\n",
    "1. Create the above matrix with one line of code and name it $a$. Print the matrix.\n",
    "2. Write code to select its principal diagonal (the sequence: 1, 6, 11, 16) in another line. Store this diagonal in $d$. Print $d$\n",
    "3. Write code to select 4 elements in the center of the array (in this case: 6, 7, 10, 11) and store it in $c$. Print $c$.\n",
    "4. Replace the diagonal elements by their squares and print the new $a$.\n",
    "\n",
    "#### Restrictions: \n",
    "To make the problem interesting, you are **NOT** allowed to:\n",
    "- Use the predefined functions or methods, such as the diagonal() method that is available in numpy"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 170,
   "metadata": {
    "colab": {},
    "colab_type": "code",
    "id": "SmNPL0dEKJ3e"
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[[ 1  2  3  4]\n",
      " [ 5  6  7  8]\n",
      " [ 9 10 11 12]\n",
      " [13 14 15 16]]\n",
      "Diagonal:  [1, 6, 11, 16]\n",
      "Centre:  [6, 7, 10, 11]\n",
      "New Matrix:  [[  1   2   3   4]\n",
      " [  5  36   7   8]\n",
      " [  9  10 121  12]\n",
      " [ 13  14  15 256]]\n"
     ]
    }
   ],
   "source": [
    "#1.\n",
    "a = np.array([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]])\n",
    "print(a)\n",
    "#2.\n",
    "d= []\n",
    "for i in range (0,4):\n",
    "    d.append(a[i][i])\n",
    "print (\"Diagonal: \",d)\n",
    "#3.\n",
    "c = []\n",
    "for i in range (1,3):\n",
    "     for j in range(1,3):\n",
    "        c.append(a[i][j]) \n",
    "print (\"Centre: \",c)\n",
    "#4.\n",
    "for i in range (4):\n",
    "    a[i][i]  = a[i][i]*a[i][i]\n",
    "print (\"New Matrix: \",a)\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "colab_type": "text",
    "id": "gh3V-1mRQeBm"
   },
   "source": [
    "## Question 2 (3 points)\n",
    "\n",
    "Let us make the above question a bit more interesting. The previous problem was easy in the sense that you could hardcode some values and it would work for all 4*4 matrices. What if you didn't know the size of the array $a$. Let us assume it is $n \\times n$.\n",
    "1. Write code that accepts a matrix $a$ as input.\n",
    "2. Write code to print the diagonal elements of $a$.\n",
    "3. For any $k$, write code to print the elements which lie in the center $k \\times k$ region of the $a$.\n",
    "4. Be sure to validate that the input and parameters are correct. See the Examples subsection below to see... examples!\n",
    "\n",
    "#### Note:\n",
    "- Same restrictions apply as above\n",
    "- You should assume that only the matrix $a$ and the integer $k$ have been defined elsewhere in the notebook are available to you. Your code will be tested on a number of test cases and should pass them all successfully\n",
    "\n",
    "\n",
    "#### Examples:\n",
    "- If we had a matrix such as the one below, with n=3, k=1, the output should be \"1\" or \"[1]\". If the user had set the parameter k=2, then an error should be raised because there isn't a 2*2 submatrix that falls directly in the middle of the original matrix.\n",
    "\n",
    "$$\\begin{bmatrix}2 & 2 & 2 \\\\2 & 1 & 2 \\\\2 & 2 & 2 \\end{bmatrix}$$\n",
    "\n",
    "- In the case of n=4, k=2, the output should be \"[[1, 1], [1, 1]]\", or an equivalent representation of those values, such as \"1 1 1 1\" or [1,1,1,1], etc. See that similar to above, setting the parameter k=1 here doesn't make sense.\n",
    "\n",
    "$$\\begin{bmatrix}2 & 2 & 2 & 2\\\\2 & 1 & 1 & 2\\\\2 & 1 & 1 & 2\\\\2 & 2 & 2 & 2\\end{bmatrix}$$\n",
    "\n",
    "- n=5. Here k can be 1 or 3. If k=1, then it returns [1]. If k=3, then it returns [[2,2,2], [2,1,2],[2,2,2]].\n",
    "\n",
    "$$\\begin{bmatrix}3 & 3 & 3 & 3 & 3\\\\3 & 2 & 2 & 2 & 3\\\\3 & 2 & 1 & 2 & 3\\\\3 & 2 & 2 & 2 & 3 \\\\ 3 & 3 & 3 & 3 & 3 \\end{bmatrix}$$"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 172,
   "metadata": {
    "colab": {},
    "colab_type": "code",
    "id": "4d2P-o5mKZG2"
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[[3 3 3 3 3]\n",
      " [3 2 2 2 3]\n",
      " [3 2 1 2 3]\n",
      " [3 2 2 2 3]\n",
      " [3 3 3 3 3]]\n",
      "Diagonal:  [3, 2, 1, 2, 3]\n",
      "Center:  [[1]]\n"
     ]
    }
   ],
   "source": [
    "#1.\n",
    "a = np.array([[3,3,3,3,3], [3,2,2,2,3],[3,2,1,2,3],[3,2,2,2,3],[3,3,3,3,3]])\n",
    "print(a)\n",
    "#2.\n",
    "n = len(a)\n",
    "d= []\n",
    "for i in range (0,n):\n",
    "    d.append(a[i][i])\n",
    "print (\"Diagonal: \",d)\n",
    "#3.\n",
    "#modify this value of k\n",
    "k = 1\n",
    "center = []\n",
    "x = int((n-k)/2)\n",
    "y = k+int((n-k)/2)\n",
    "center = (a[x:y,x:y])\n",
    "print (\"Center: \",center)\n",
    "\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "colab_type": "text",
    "id": "1vUKeUCMUl08"
   },
   "source": [
    "## Question 3 (6 points)\n",
    "\n",
    "In this question, we will look at the speedup that vectorization brings to the table. The dot product of two vectors $\\overline{a}=[a_1, a_2, \\ldots, a_n]$ and $\\overline{b}=[b_1, b_2, \\ldots, b_n]$  is defined as:\n",
    "$$ \\overline{a} \\cdot \\overline{b} = \\sum_{i=1}^n a_i b_i$$\n",
    "\n",
    "1. Write a function to calculate the dot product of two lists using `for` loops.\n",
    "2. Use numpy's functionality to do the same.\n",
    "3. Find out computation times for arrays of sizes (10,000, 20,0000, ..., 100,000) and plot the two sets of times in a line plot."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 37,
   "metadata": {
    "colab": {},
    "colab_type": "code",
    "id": "gyFm-preaCoM"
   },
   "outputs": [
    {
     "data": {
      "image/png": "iVBORw0KGgoAAAANSUhEUgAAAYwAAAELCAYAAADKjLEqAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAALEgAACxIB0t1+/AAAADl0RVh0U29mdHdhcmUAbWF0cGxvdGxpYiB2ZXJzaW9uIDIuMi4yLCBodHRwOi8vbWF0cGxvdGxpYi5vcmcvhp/UCwAAIABJREFUeJzt3XmczfX+wPHX21iGypqrbpahSEKWiaIsKVEiXS4qSykXuXHrVtrc6NeNopBytaCkVEopSkJJhFGyFY2lTJst+zoz798fn++MY8xyhvnOOXPO+/l4nMec893O+xzHeZ/PLqqKMcYYk5NCoQ7AGGNMwWAJwxhjTFAsYRhjjAmKJQxjjDFBsYRhjDEmKJYwjDHGBMUShjHGmKBYwjDGGBMUSxjGGGOCUjjUAeSVs88+W+Pi4kIdhjHGFCgrVqzYoarlgzk2YhJGXFwcCQkJoQ7DGGMKFBH5KdhjrUrKGGNMUCxhGGOMCYolDGOMMUGJmDaMzBw7doykpCQOHz4c6lBMlIqNjaVixYoUKVIk1KEYc9oiOmEkJSVx1llnERcXh4iEOhwTZVSVnTt3kpSURNWqVUMdjjGnLaKrpA4fPky5cuUsWZiQEBHKlStnJVwTMSI6YQCWLExI2efPRJKITxjGGBPRFi+GDz/Ml6eyhJGPHnvsMUaOHJntMZMnT+bXX3/Nl3hatGhxSoMdd+/ezQsvvJAnMcycOZPhw4fnybV69erF9OnT8+RaxhQIr70GLVvCo49CSorvT2cJI8ycbsJITk7Ow2gyl5cJo3379gwePDhPrmVM1EhNhcGDoWdPaNoU5s+HmBjfn9YShs+eeOIJLrzwQq6++mrWr1+fvn3lypVcdtll1K1bl44dO/Lnn38yffp0EhISuOWWW6hXrx6HDh064VotWrRg0KBBNGnShNq1a7Ns2TLAlVz69OlD69at6dGjB4cPH+a2226jTp061K9fnwULFgBw6NAhunbtSt26denSpcsJ1z/zzDPT70+fPp1evXoB8Mcff9CxY0cuueQSLrnkEhYvXszgwYPZuHEj9erV47777jshxi1btlC7du30xyNHjuSxxx4DYOzYsdSqVYu6devStWtXwCXIAQMGAK6EcPfdd9OkSROqVauWXlpITU2lf//+XHzxxbRr147rrrsux5LEvHnzqF+/PnXq1OH222/nyJEj2W6Pi4vjgQceoFGjRjRq1IjExMRsr29MyOzfDzfdBCNGwD/+AXPmQNmy+fLUEd2t9gSDBsHKlXl7zXr1YPToLHevWLGCadOm8e2335KcnEyDBg1o2LAhAD169OC5556jefPmDBkyhKFDhzJ69GjGjRvHyJEjiY+Pz/SaBw4cYPHixSxcuJDbb7+dNWvWpD/XokWLKF68OKNGjQJg9erV/PDDD7Ru3ZoNGzYwfvx4SpQowapVq1i1ahUNGjTI8SXefffdNG/enBkzZpCSksL+/fsZPnw4a9asYWUu38/hw4ezefNmihUrxu7duzM95rfffmPRokX88MMPtG/fnk6dOvHee++xZcsWVq9ezbZt27jooou4/fbbs3yew4cP06tXL+bNm0eNGjXo0aMH48ePp2/fvpluHzRoEAAlS5Zk2bJlvPbaawwaNIiPPvooV6/PGN/99BO0bw9r1sDYsTBgAORjxworYfjoyy+/pGPHjpQoUYKSJUvSvn17APbs2cPu3btp3rw5AD179mThwoVBXbNbt24ANGvWjL1796Z/8bZv357ixYsDsGjRIrp37w5AzZo1qVKlChs2bGDhwoXceuutANStW5e6devm+Hzz58+nX79+AMTExFCqVKlgX/5J6tatyy233MLrr79O4cKZ/1a58cYbKVSoELVq1eKPP/5Ifz2dO3emUKFCnHPOObRs2TLb51m/fj1Vq1alRo0awPH3N6vtadLe227durFkyZJTfp3G+GLJEmjUyCWN2bPhn//M12QB0VTCyKYk4Ke87laZ8Xppj88444z0baqa63gCt5/OuIHChQuTmpqa6bVmzZrFwoULmTlzJo8//jhr16496fxixYql3097Hdm9nsxkdXxO1wl8D6w7rAkrr78OvXtDpUrwxRdQs2ZIwrASho+aNWvGjBkzOHToEPv27eNDr+tbqVKlKFOmDF9++SUAU6ZMSS9tnHXWWezbty/La7711luA+9VdqlSpTH/xN2vWjKlTpwKwYcMGfv75Zy688MITtq9Zs4ZVq1aln1OhQgW+//57UlNTmTFjRvr2Vq1aMX78eABSUlLYu3dvtjFWqFCBbdu2sXPnTo4cOZJerZOamsrWrVtp2bIlTz31FLt372b//v1BvItwxRVX8O6775Kamsoff/zB559/nu3xNWvWZMuWLent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\n",
      "text/plain": [
       "<Figure size 432x288 with 1 Axes>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "## Boilerplate code for Question 3\n",
    "gen = np.random.RandomState(seed=42)\n",
    "import timeit\n",
    "\n",
    "def time_function(f, *args):\n",
    "  \"\"\"\n",
    "  This is a simple utility function to measure the runtime \n",
    "  of a python function. It will return the result of the function\n",
    "  execution and the time taken to run that function. Any arguments \n",
    "  required by the function to run should be passed after the function name.\n",
    "  INPUT: function name, arg1, arg2, ...\n",
    "  OUTPUT: Output of the passed function, time taken to run it\n",
    "  \"\"\"   \n",
    "  start = timeit.default_timer()\n",
    "  ret = f(*args)\n",
    "  f(*args)\n",
    "  f(*args)\n",
    "  stop = timeit.default_timer()\n",
    "  return ret, (stop-start)/3\n",
    "\n",
    "def random_int_array(array_size):\n",
    "  # The low and high arguments below are used to specify the range of random\n",
    "  # values that will be used to generate the random integers.\n",
    "  return np.random.randint(low=0, high=1000000, size=array_size)\n",
    "\n",
    "#1.Dot Product using a for loop\n",
    "def calculate_dot_product(a, b):\n",
    "  \"\"\"\n",
    "    INPUT: a and b are lists\n",
    "    OUTPUT: dot product\n",
    "    Complete this function\n",
    "  \"\"\"\n",
    "  n1 = len(a)\n",
    "  n2 = len(b)\n",
    "  sum = 0\n",
    "  for i in range(0,n1):\n",
    "    sum = sum + a[i]*b[i]\n",
    "  return int(sum)\n",
    "\n",
    "#2.Dot product using numpy\n",
    "def calculate_dot_product_numpy(a, b):\n",
    "    sum = np.dot(a,b)\n",
    "    return int(sum)\n",
    "\n",
    "time1 = []\n",
    "time2 = []\n",
    "size1 = []\n",
    "size2 = []\n",
    "sizes = (10000 * i for i in range(1, 11))\n",
    "for size in sizes:\n",
    "  a = gen.rand(size)\n",
    "  b = gen.rand(size)\n",
    "  dp1, dp1_time = time_function(calculate_dot_product,a,b)\n",
    "  dp2, dp2_time = time_function(calculate_dot_product_numpy,a,b)\n",
    "  assert(dp1 == dp2)\n",
    "  time1.append(dp1_time)\n",
    "  time2.append(dp2_time)\n",
    "  size1.append(size)\n",
    "  size2.append(size)\n",
    "\n",
    "#3. Graph for given inputs for both the function\n",
    "plt.plot(size1,time1, 'r',label='dot product using loop')\n",
    "plt.plot(size2,time2, 'b',label='dot product using numpy')\n",
    "plt.xlabel('input_size')\n",
    "plt.ylabel('time')\n",
    "plt.legend()\n",
    "plt.show()  "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "colab_type": "text",
    "id": "xBdVl9BY3AdU"
   },
   "source": [
    "## Question 4 (4 points)\n",
    "\n",
    "We have provided code which loads an interesting dataset about breast cancer in a pandas dataframe variable called `data`. We also provide 5 samples of the dataset.\n",
    "The breast cancer dataset is loaded into a dataframe called \"data\" and the \"labels\" are stored as a dataframe as well.  \n",
    "\n",
    "Please bear in mind that you cannot actually look at the entire dataset in the notebook since it has many columns. If you want to look at the entire dataframe/dataset, use data.to_csv() to write the data frame to a csv file. For the questions given, you don't actually need to look at the entire dataset. A sample of the data shown in the next block is enough.\n",
    "\n",
    "Write code to:\n",
    "\n",
    "1.  Get the total number of samples whose \"mean perimeter\" is greater than 130.\n",
    "2.  Group the \"worst area\" column based on the \"labels\" and get the maximum \"worst area\" for each group. In this case, there will be 2 groups since we have only 2 labels.\n",
    "3.  Get the column which has the minimum sum and subtract each value of that column by its mean. i.e., (column value - mean of the column)\n",
    "\n",
    "Information about the dataset columns can be found at: http://scikit-learn.org/stable/modules/generated/sklearn.datasets.load_breast_cancer.html"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 53,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/",
     "height": 267
    },
    "colab_type": "code",
    "id": "_ceJP6tPcWu_",
    "outputId": "6069e1c8-efc7-46aa-d106-24d0be25207b"
   },
   "outputs": [
    {
     "data": {
      "text/html": [
       "<div>\n",
       "<style scoped>\n",
       "    .dataframe tbody tr th:only-of-type {\n",
       "        vertical-align: middle;\n",
       "    }\n",
       "\n",
       "    .dataframe tbody tr th {\n",
       "        vertical-align: top;\n",
       "    }\n",
       "\n",
       "    .dataframe thead th {\n",
       "        text-align: right;\n",
       "    }\n",
       "</style>\n",
       "<table border=\"1\" class=\"dataframe\">\n",
       "  <thead>\n",
       "    <tr style=\"text-align: right;\">\n",
       "      <th></th>\n",
       "      <th>mean radius</th>\n",
       "      <th>mean texture</th>\n",
       "      <th>mean perimeter</th>\n",
       "      <th>mean area</th>\n",
       "      <th>mean smoothness</th>\n",
       "      <th>mean compactness</th>\n",
       "      <th>mean concavity</th>\n",
       "      <th>mean concave points</th>\n",
       "      <th>mean symmetry</th>\n",
       "      <th>mean fractal dimension</th>\n",
       "      <th>...</th>\n",
       "      <th>worst radius</th>\n",
       "      <th>worst texture</th>\n",
       "      <th>worst perimeter</th>\n",
       "      <th>worst area</th>\n",
       "      <th>worst smoothness</th>\n",
       "      <th>worst compactness</th>\n",
       "      <th>worst concavity</th>\n",
       "      <th>worst concave points</th>\n",
       "      <th>worst symmetry</th>\n",
       "      <th>worst fractal dimension</th>\n",
       "    </tr>\n",
       "  </thead>\n",
       "  <tbody>\n",
       "    <tr>\n",
       "      <th>0</th>\n",
       "      <td>17.99</td>\n",
       "      <td>10.38</td>\n",
       "      <td>122.80</td>\n",
       "      <td>1001.0</td>\n",
       "      <td>0.11840</td>\n",
       "      <td>0.27760</td>\n",
       "      <td>0.3001</td>\n",
       "      <td>0.14710</td>\n",
       "      <td>0.2419</td>\n",
       "      <td>0.07871</td>\n",
       "      <td>...</td>\n",
       "      <td>25.38</td>\n",
       "      <td>17.33</td>\n",
       "      <td>184.60</td>\n",
       "      <td>2019.0</td>\n",
       "      <td>0.1622</td>\n",
       "      <td>0.6656</td>\n",
       "      <td>0.7119</td>\n",
       "      <td>0.2654</td>\n",
       "      <td>0.4601</td>\n",
       "      <td>0.11890</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>1</th>\n",
       "      <td>20.57</td>\n",
       "      <td>17.77</td>\n",
       "      <td>132.90</td>\n",
       "      <td>1326.0</td>\n",
       "      <td>0.08474</td>\n",
       "      <td>0.07864</td>\n",
       "      <td>0.0869</td>\n",
       "      <td>0.07017</td>\n",
       "      <td>0.1812</td>\n",
       "      <td>0.05667</td>\n",
       "      <td>...</td>\n",
       "      <td>24.99</td>\n",
       "      <td>23.41</td>\n",
       "      <td>158.80</td>\n",
       "      <td>1956.0</td>\n",
       "      <td>0.1238</td>\n",
       "      <td>0.1866</td>\n",
       "      <td>0.2416</td>\n",
       "      <td>0.1860</td>\n",
       "      <td>0.2750</td>\n",
       "      <td>0.08902</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>2</th>\n",
       "      <td>19.69</td>\n",
       "      <td>21.25</td>\n",
       "      <td>130.00</td>\n",
       "      <td>1203.0</td>\n",
       "      <td>0.10960</td>\n",
       "      <td>0.15990</td>\n",
       "      <td>0.1974</td>\n",
       "      <td>0.12790</td>\n",
       "      <td>0.2069</td>\n",
       "      <td>0.05999</td>\n",
       "      <td>...</td>\n",
       "      <td>23.57</td>\n",
       "      <td>25.53</td>\n",
       "      <td>152.50</td>\n",
       "      <td>1709.0</td>\n",
       "      <td>0.1444</td>\n",
       "      <td>0.4245</td>\n",
       "      <td>0.4504</td>\n",
       "      <td>0.2430</td>\n",
       "      <td>0.3613</td>\n",
       "      <td>0.08758</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>3</th>\n",
       "      <td>11.42</td>\n",
       "      <td>20.38</td>\n",
       "      <td>77.58</td>\n",
       "      <td>386.1</td>\n",
       "      <td>0.14250</td>\n",
       "      <td>0.28390</td>\n",
       "      <td>0.2414</td>\n",
       "      <td>0.10520</td>\n",
       "      <td>0.2597</td>\n",
       "      <td>0.09744</td>\n",
       "      <td>...</td>\n",
       "      <td>14.91</td>\n",
       "      <td>26.50</td>\n",
       "      <td>98.87</td>\n",
       "      <td>567.7</td>\n",
       "      <td>0.2098</td>\n",
       "      <td>0.8663</td>\n",
       "      <td>0.6869</td>\n",
       "      <td>0.2575</td>\n",
       "      <td>0.6638</td>\n",
       "      <td>0.17300</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>4</th>\n",
       "      <td>20.29</td>\n",
       "      <td>14.34</td>\n",
       "      <td>135.10</td>\n",
       "      <td>1297.0</td>\n",
       "      <td>0.10030</td>\n",
       "      <td>0.13280</td>\n",
       "      <td>0.1980</td>\n",
       "      <td>0.10430</td>\n",
       "      <td>0.1809</td>\n",
       "      <td>0.05883</td>\n",
       "      <td>...</td>\n",
       "      <td>22.54</td>\n",
       "      <td>16.67</td>\n",
       "      <td>152.20</td>\n",
       "      <td>1575.0</td>\n",
       "      <td>0.1374</td>\n",
       "      <td>0.2050</td>\n",
       "      <td>0.4000</td>\n",
       "      <td>0.1625</td>\n",
       "      <td>0.2364</td>\n",
       "      <td>0.07678</td>\n",
       "    </tr>\n",
       "  </tbody>\n",
       "</table>\n",
       "<p>5 rows Ã— 30 columns</p>\n",
       "</div>"
      ],
      "text/plain": [
       "   mean radius  mean texture  mean perimeter  mean area  mean smoothness  \\\n",
       "0        17.99         10.38          122.80     1001.0          0.11840   \n",
       "1        20.57         17.77          132.90     1326.0          0.08474   \n",
       "2        19.69         21.25          130.00     1203.0          0.10960   \n",
       "3        11.42         20.38           77.58      386.1          0.14250   \n",
       "4        20.29         14.34          135.10     1297.0          0.10030   \n",
       "\n",
       "   mean compactness  mean concavity  mean concave points  mean symmetry  \\\n",
       "0           0.27760          0.3001              0.14710         0.2419   \n",
       "1           0.07864          0.0869              0.07017         0.1812   \n",
       "2           0.15990          0.1974              0.12790         0.2069   \n",
       "3           0.28390          0.2414              0.10520         0.2597   \n",
       "4           0.13280          0.1980              0.10430         0.1809   \n",
       "\n",
       "   mean fractal dimension           ...             worst radius  \\\n",
       "0                 0.07871           ...                    25.38   \n",
       "1                 0.05667           ...                    24.99   \n",
       "2                 0.05999           ...                    23.57   \n",
       "3                 0.09744           ...                    14.91   \n",
       "4                 0.05883           ...                    22.54   \n",
       "\n",
       "   worst texture  worst perimeter  worst area  worst smoothness  \\\n",
       "0          17.33           184.60      2019.0            0.1622   \n",
       "1          23.41           158.80      1956.0            0.1238   \n",
       "2          25.53           152.50      1709.0            0.1444   \n",
       "3          26.50            98.87       567.7            0.2098   \n",
       "4          16.67           152.20      1575.0            0.1374   \n",
       "\n",
       "   worst compactness  worst concavity  worst concave points  worst symmetry  \\\n",
       "0             0.6656           0.7119                0.2654          0.4601   \n",
       "1             0.1866           0.2416                0.1860          0.2750   \n",
       "2             0.4245           0.4504                0.2430          0.3613   \n",
       "3             0.8663           0.6869                0.2575          0.6638   \n",
       "4             0.2050           0.4000                0.1625          0.2364   \n",
       "\n",
       "   worst fractal dimension  \n",
       "0                  0.11890  \n",
       "1                  0.08902  \n",
       "2                  0.08758  \n",
       "3                  0.17300  \n",
       "4                  0.07678  \n",
       "\n",
       "[5 rows x 30 columns]"
      ]
     },
     "execution_count": 53,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "#Starter code. Do not make changes to this code block.\n",
    "\n",
    "from sklearn.datasets import load_breast_cancer\n",
    "raw_data = load_breast_cancer()\n",
    "\n",
    "data = pd.DataFrame(raw_data[\"data\"], columns= raw_data[\"feature_names\"])\n",
    "labels = pd.DataFrame(raw_data[\"target\"], columns = [\"target\"])\n",
    "data.head()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 169,
   "metadata": {
    "colab": {},
    "colab_type": "code",
    "id": "aI1QgmAx2man",
    "scrolled": true
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Samples with perimeter greater than 130:  51\n",
      "1      132.9\n",
      "4      135.1\n",
      "12     132.4\n",
      "23     137.2\n",
      "78     143.7\n",
      "82     171.5\n",
      "95     132.4\n",
      "108    152.8\n",
      "122    166.2\n",
      "129    130.4\n",
      "162    130.7\n",
      "164    152.1\n",
      "180    182.1\n",
      "181    142.7\n",
      "202    158.9\n",
      "210    134.7\n",
      "212    188.5\n",
      "233    134.4\n",
      "236    153.5\n",
      "237    132.5\n",
      "250    138.9\n",
      "252    130.7\n",
      "256    133.6\n",
      "260    132.9\n",
      "265    135.7\n",
      "272    147.3\n",
      "302    134.7\n",
      "321    131.1\n",
      "323    135.9\n",
      "339    155.1\n",
      "352    174.2\n",
      "365    133.8\n",
      "366    133.7\n",
      "368    140.9\n",
      "369    147.2\n",
      "372    141.3\n",
      "373    134.8\n",
      "393    144.4\n",
      "432    133.8\n",
      "449    138.1\n",
      "461    186.9\n",
      "499    137.8\n",
      "503    152.1\n",
      "517    130.5\n",
      "521    165.5\n",
      "533    134.7\n",
      "535    137.8\n",
      "563    143.0\n",
      "564    142.0\n",
      "565    131.2\n",
      "567    140.1\n",
      "Name: mean_perimeter, dtype: float64\n",
      "Index(['mean_radius', 'mean_texture', 'mean_perimeter', 'mean_area',\n",
      "       'mean_smoothness', 'mean_compactness', 'mean_concavity',\n",
      "       'mean_concave_points', 'mean_symmetry', 'mean_fractal_dimension',\n",
      "       'radius_error', 'texture_error', 'perimeter_error', 'area_error',\n",
      "       'smoothness_error', 'compactness_error', 'concavity_error',\n",
      "       'concave_points_error', 'symmetry_error', 'fractal_dimension_error',\n",
      "       'worst_radius', 'worst_texture', 'worst_perimeter', 'worst_area',\n",
      "       'worst_smoothness', 'worst_compactness', 'worst_concavity',\n",
      "       'worst_concave_points', 'worst_symmetry', 'worst_fractal_dimension'],\n",
      "      dtype='object')\n",
      "     target\n",
      "0         0\n",
      "1         0\n",
      "2         0\n",
      "3         0\n",
      "4         0\n",
      "5         0\n",
      "6         0\n",
      "7         0\n",
      "8         0\n",
      "9         0\n",
      "10        0\n",
      "11        0\n",
      "12        0\n",
      "13        0\n",
      "14        0\n",
      "15        0\n",
      "16        0\n",
      "17        0\n",
      "18        0\n",
      "19        1\n",
      "20        1\n",
      "21        1\n",
      "22        0\n",
      "23        0\n",
      "24        0\n",
      "25        0\n",
      "26        0\n",
      "27        0\n",
      "28        0\n",
      "29        0\n",
      "..      ...\n",
      "539       1\n",
      "540       1\n",
      "541       1\n",
      "542       1\n",
      "543       1\n",
      "544       1\n",
      "545       1\n",
      "546       1\n",
      "547       1\n",
      "548       1\n",
      "549       1\n",
      "550       1\n",
      "551       1\n",
      "552       1\n",
      "553       1\n",
      "554       1\n",
      "555       1\n",
      "556       1\n",
      "557       1\n",
      "558       1\n",
      "559       1\n",
      "560       1\n",
      "561       1\n",
      "562       0\n",
      "563       0\n",
      "564       0\n",
      "565       0\n",
      "566       0\n",
      "567       0\n",
      "568       1\n",
      "\n",
      "[569 rows x 1 columns]\n"
     ]
    }
   ],
   "source": [
    "\n",
    "data.columns = data.columns.str.replace(' ', '_')\n",
    "m = data[data.mean_perimeter > 130]\n",
    "print('Samples with perimeter greater than 130: ', len(m))\n",
    "print(m.mean_perimeter)\n",
    "print (data.columns)\n",
    "print (labels)\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 86,
   "metadata": {
    "colab": {},
    "colab_type": "code",
    "id": "lWAS-epe4DnR"
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Label 0 worst area group: \n",
      "  [2019.0, 1956.0, 1709.0, 567.7, 1575.0, 741.6, 1606.0, 897.0, 739.3, 711.4, 1150.0, 1299.0, 1332.0, 876.5, 697.7, 943.2, 1138.0, 1315.0, 2398.0, 980.9, 2615.0, 2215.0, 1461.0, 896.9, 1403.0, 1269.0, 1227.0, 1670.0, 888.7, 1344.0, 1813.0, 1261.0, 1229.0, 799.6, 698.8, 740.4, 787.9, 514.0, 1651.0, 907.2, 740.7, 1567.0, 759.4, 1321.0, 1030.0, 2145.0, 985.5, 959.5, 888.3, 925.1, 1866.0, 1681.0, 812.4, 1223.0, 1610.0, 1623.0, 2562.0, 1298.0, 1603.0, 808.9, 1623.0, 830.9, 1025.0, 1750.0, 826.4, 906.5, 827.2, 2360.0, 1095.0, 1272.0, 1261.0, 1549.0, 2073.0, 848.7, 1538.0, 1589.0, 1156.0, 1175.0, 1590.0, 653.6, 971.4, 1233.0, 591.7, 1302.0, 1495.0, 2232.0, 2403.0, 1260.0, 1660.0, 993.6, 1102.0, 981.2, 3216.0, 2089.0, 1269.0, 973.1, 1410.0, 762.4, 768.9, 784.7, 806.9, 1228.0, 1688.0, 1044.0, 1239.0, 1986.0, 1153.0, 989.5, 1210.0, 1656.0, 2499.0, 1021.0, 811.3, 750.1, 2009.0, 2477.0, 1088.0, 706.0, 1189.0, 1872.0, 2944.0, 1750.0, 1408.0, 1417.0, 2010.0, 1933.0, 1222.0, 1972.0, 826.0, 1926.0, 928.8, 1226.0, 1035.0, 1844.0, 1218.0, 1295.0, 988.6, 1436.0, 3432.0, 2384.0, 1320.0, 1236.0, 1724.0, 1628.0, 1031.0, 553.6, 2053.0, 1696.0, 1485.0, 1657.0, 1938.0, 1121.0, 975.2, 1070.0, 1362.0, 1873.0, 2906.0, 1540.0, 915.3, 3234.0, 1050.0, 1780.0, 1671.0, 3143.0, 2227.0, 1165.0, 1535.0, 1946.0, 508.1, 758.2, 1313.0, 1359.0, 2081.0, 1304.0, 1349.0, 931.4, 1748.0, 832.7, 1479.0, 1603.0, 869.3, 1284.0, 1292.0, 1437.0, 2022.0, 1421.0, 1648.0, 4254.0, 1437.0, 939.7, 1740.0, 1084.0, 1426.0, 1600.0, 1760.0, 788.0, 2782.0, 909.4, 844.4, 967.0, 1493.0, 1646.0, 2642.0, 1645.0, 1809.0, 728.3, 915.0, 1819.0, 2027.0, 1731.0, 1124.0, 1821.0]\n",
      "Label 1 worst area group: \n",
      "  [711.2, 630.5, 314.9, 545.9, 242.2, 582.6, 698.8, 516.5, 656.7, 527.2, 506.2, 624.1, 274.9, 368.6, 273.9, 310.1, 330.7, 466.7, 324.7, 554.9, 284.4, 611.1, 605.5, 622.1, 525.1, 614.9, 567.9, 574.7, 803.6, 803.7, 830.6, 699.4, 495.2, 366.1, 512.5, 185.2, 547.8, 361.2, 402.8, 521.7, 544.1, 518.1, 367.0, 527.4, 709.0, 374.4, 284.4, 583.0, 270.0, 510.5, 745.5, 632.1, 725.9, 762.6, 545.2, 922.8, 546.7, 462.0, 434.0, 342.9, 503.0, 643.8, 441.2, 509.6, 809.7, 766.9, 725.9, 616.7, 249.8, 380.5, 440.8, 677.3, 564.2, 1032.0, 532.8, 470.0, 543.9, 553.0, 782.1, 414.0, 793.7, 549.1, 396.5, 408.3, 259.2, 390.2, 608.8, 570.7, 467.2, 437.0, 521.5, 489.5, 546.7, 579.5, 303.8, 600.6, 638.4, 677.9, 331.6, 639.3, 932.7, 546.3, 531.2, 403.7, 706.2, 686.6, 375.6, 708.8, 873.2, 395.4, 808.2, 624.0, 452.3, 470.9, 335.9, 715.5, 764.0, 683.4, 543.4, 472.9, 706.0, 402.8, 602.0, 639.1, 455.7, 491.8, 508.9, 424.8, 661.5, 597.5, 410.4, 684.6, 457.5, 355.2, 472.4, 458.0, 739.1, 670.0, 533.7, 595.6, 564.1, 546.1, 577.0, 437.6, 459.3, 767.3, 809.8, 585.4, 517.8, 553.7, 661.1, 392.2, 819.7, 362.7, 551.3, 375.4, 489.8, 476.5, 636.9, 285.5, 698.7, 672.4, 483.1, 840.8, 618.8, 467.8, 240.1, 544.2, 513.1, 297.1, 515.9, 390.4, 599.5, 583.1, 574.4, 749.9, 523.4, 634.3, 436.1, 492.7, 544.3, 576.0, 384.0, 862.1, 353.6, 440.0, 516.4, 357.1, 562.6, 880.8, 475.8, 496.2, 542.5, 453.5, 547.4, 591.2, 694.4, 302.0, 439.6, 585.7, 621.2, 579.7, 1009.0, 663.5, 624.6, 819.1, 670.6, 861.5, 351.9, 680.6, 657.0, 476.1, 447.1, 488.4, 600.5, 623.7, 529.9, 745.3, 450.0, 394.5, 317.0, 559.5, 684.5, 675.2, 591.0, 496.7, 562.0, 589.5, 621.9, 580.9, 533.1, 472.4, 947.9, 645.8, 610.2, 521.3, 471.4, 301.0, 867.1, 522.9, 359.4, 566.9, 458.0, 520.5, 809.2, 475.7, 708.8, 380.9, 376.3, 440.4, 489.5, 421.1, 586.8, 515.8, 777.5, 626.9, 750.0, 749.1, 688.9, 476.4, 706.6, 366.3, 513.9, 829.5, 830.5, 507.2, 523.7, 749.9, 633.5, 705.6, 527.8, 632.9, 628.5, 349.9, 734.6, 495.1, 687.6, 733.5, 689.1, 380.2, 528.1, 385.2, 567.6, 906.6, 558.9, 433.1, 605.8, 828.5, 718.9, 467.6, 547.4, 830.5, 660.2, 686.5, 854.3, 580.6, 831.0, 549.8, 622.9, 1210.0, 534.0, 648.3, 783.6, 633.7, 607.3, 856.9, 552.0, 300.2, 328.1, 515.3, 411.1, 928.2, 473.8, 760.2, 862.0, 478.6, 674.7, 624.1, 326.6, 435.9, 701.9, 376.5, 275.6, 719.8, 564.9, 653.3, 549.9, 552.3, 550.6, 773.4, 407.5, 487.7, 248.0, 223.6, 457.8, 808.9, 826.4, 629.6, 688.6, 729.8, 384.9, 357.4, 364.2, 505.6, 412.3, 436.6, 594.7, 295.8, 595.7, 357.6, 347.3, 330.6, 733.5, 474.2, 706.7, 439.6, 268.6]\n",
      "Max worst area of label 0:  \n",
      " 4254.0\n",
      "Max worst area of label 1: \n",
      " 1210.0\n"
     ]
    }
   ],
   "source": [
    "list1 = []\n",
    "list2 = []\n",
    "flist1 = []\n",
    "flist2 = []\n",
    "\n",
    "for elem in labels.target:\n",
    "    list2.append(elem)\n",
    "for elem in data.worst_area:\n",
    "    list1.append(elem)\n",
    "    \n",
    "for i in range(0,len(list2)):\n",
    "    if list2[i] == 0 :\n",
    "        flist1.append(list1[i])\n",
    "    else:\n",
    "        flist2.append(list1[i])\n",
    "print ('Label 0 worst area group: \\n ',flist1)\n",
    "print ('Label 1 worst area group: \\n ',flist2)\n",
    "print ('Max worst area of label 0:  \\n',max(flist1))\n",
    "print ('Max worst area of label 1: \\n',max(flist2))\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 168,
   "metadata": {
    "colab": {},
    "colab_type": "code",
    "id": "KggURDgi9vVl"
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Column with minimum sum:  fractal_dimension_error\n",
      "0      0.002398\n",
      "1     -0.000263\n",
      "2      0.000776\n",
      "3      0.005413\n",
      "4      0.001320\n",
      "5      0.001287\n",
      "6     -0.001616\n",
      "7      0.001617\n",
      "8     -0.000046\n",
      "9      0.006285\n",
      "10    -0.000753\n",
      "11     0.000349\n",
      "12     0.009045\n",
      "13    -0.000793\n",
      "14     0.004298\n",
      "15     0.001671\n",
      "16    -0.001710\n",
      "17     0.000347\n",
      "18    -0.001798\n",
      "19    -0.001495\n",
      "20    -0.001370\n",
      "21    -0.000827\n",
      "22     0.000599\n",
      "23    -0.001808\n",
      "24    -0.000994\n",
      "25     0.003649\n",
      "26    -0.000084\n",
      "27     0.000422\n",
      "28    -0.000828\n",
      "29    -0.000053\n",
      "         ...   \n",
      "539    0.003756\n",
      "540    0.001717\n",
      "541    0.002316\n",
      "542   -0.001169\n",
      "543   -0.002452\n",
      "544   -0.000196\n",
      "545   -0.001212\n",
      "546   -0.001189\n",
      "547    0.002095\n",
      "548    0.000359\n",
      "549   -0.000818\n",
      "550   -0.001567\n",
      "551    0.000928\n",
      "552   -0.002069\n",
      "553    0.000828\n",
      "554   -0.000994\n",
      "555    0.001143\n",
      "556   -0.001517\n",
      "557   -0.000471\n",
      "558    0.000611\n",
      "559    0.000943\n",
      "560    0.001509\n",
      "561   -0.002022\n",
      "562    0.002347\n",
      "563    0.002418\n",
      "564    0.000444\n",
      "565   -0.001297\n",
      "566    0.000097\n",
      "567    0.002390\n",
      "568   -0.001012\n",
      "Name: fractal_dimension_error, Length: 569, dtype: float64\n"
     ]
    }
   ],
   "source": [
    "s = data.sum()\n",
    "min_col = s.idxmin()\n",
    "print ('Column with minimum sum: ', min_col)\n",
    "mean = np.mean(data[min_col])\n",
    "print (data[min_col] - mean)\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "colab_type": "text",
    "id": "kiYPu2_sMrrh"
   },
   "source": [
    "## Question 5 (7 points)\n",
    "\n",
    "### Part A\n",
    "\n",
    "Write a function which takes three inputs and produces a plot using matplotlib. The first two inputs are lists. Each list contains a certain number of tuples. Each tuple in turn contains the $x$ and $y$ co-ordinates of a point. The third input is a stand-alone tuple containing the co-efficients $(a, b, c)$ of a line represented by $ax + by + c = 0$.\n",
    "\n",
    "The function should plot the first set of points with a red '+' and the second set of points with a blue 'o'. The function should also plot the line in green color. Give a suitable legend and name the axes. If the final tuple isn't provided, the function should gracefully avoid printing the line instead of throwing an error. Feel feel to modify the function definition accordingly.\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 167,
   "metadata": {
    "colab": {},
    "colab_type": "code",
    "id": "p_QBjYa-MrOq"
   },
   "outputs": [
    {
     "data": {
      "image/png": "iVBORw0KGgoAAAANSUhEUgAAAYQAAAEKCAYAAAASByJ7AAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAALEgAACxIB0t1+/AAAADl0RVh0U29mdHdhcmUAbWF0cGxvdGxpYiB2ZXJzaW9uIDIuMi4yLCBodHRwOi8vbWF0cGxvdGxpYi5vcmcvhp/UCwAAHnlJREFUeJzt3Xm81mP+x/HXR8bSIksZplKWCP1KnIhMkqJoaqIeMSEashMlLbQMlUTWLNmHY5mEaFpkiskSLaJdkdJGtlFaT+fz++O6I62nzrnPdS/v5+PR45z7Pnfdbw+n8+57Xd/ruszdERER2S12ABERSQ0qBBERAVQIIiKSoEIQERFAhSAiIgkqBBERAVQIIiKSoEIQERFAhSAiIgm7xw6wM8qVK+dVqlSJHUNEJK1Mnjz5O3cvv6PXpVUhVKlShUmTJsWOISKSVsxsQUFepyEjEREBVAgiIpKgQhAREUCFICIiCSoEEREBVAgiaSs3F6pUgd12Cx9zc2MnknSXVredikiQmwvt28OqVeHxggXhMUCbNvFySXrTFYJIGure/bcy2GjVqvC8yK5SIYikoYULd+55kYJQIYikoUMO2bnnRQpChSCShvr0gZIlf/9cyZLheZFdpUIQSUNt2sDgwVC5MpiFj4MHa0JZCkd3GYmkqTZtVABStHSFICIigApBREQSVAgiIgKoEEREJEGFICIigApBREQSVAgiIgKoEEREJEGFICIigApBREQSVAgiIgKoEEREJEGFICIigApBREQSVAgiIgKkQCGYWQkz+8TMhsfOIpIsublQpQrstlv4mJsbO5HIllLhgJwbgFnAPrGDiCRDbi60bw+rVoXHCxaEx6ADbiS1RL1CMLOKwDnAEzFziCRT9+6/lcFGq1aF50V2yB2GDYMNG5L+VrGHjO4DOgP523qBmbU3s0lmNmn58uXFl0ykiCxcuHPPi/zq44+hbl3461/hlVeS/nbRCsHMmgLfuvvk7b3O3Qe7e46755QvX76Y0okUnUMO2bnnRVi8GC6+GE46CebPh6eeglatkv62Ma8Q6gLNzOwr4CWggZk9HzGPSFL06QMlS/7+uZIlw/Miv7N6Ndx+Oxx5JLz8MnTpAp9/DpdeGu5ISLJoheDuXd29ortXAc4Hxrr7hbHyiCRLmzYweDBUrgxm4ePgwZpQlk24hwKoVg169IAmTWD2bOjXD8qUKbYYqXCXkUjGa9NGBSDbMHkydOgA770HNWvCs89C/fpRosSeVAbA3d9x96axc4iIFJulS8NQUO3aYVjo8cdDOUQqA9AVgohI8VqzBgYOhL59Yf16uPnmcA/yPvGXYqkQRESKgzsMHRoK4KuvoEULGDAADj88drJfpcSQkYhIRvvkkzAU1KpVuBL4z3/g1VdTqgxAhSAikjzLlsHf/w4nnAAzZ8Kjj8KUKdCgQexkW6UhIxGRorZmDdx/f1hssno13HQT3HYblC0bO9l2qRBERIqKO7z2GnTqFFYYN20K99wTFpqlAQ0ZiYgUhU8/hTPOgPPOC0vRR4+GN99MmzIAFYKISOF8+23Yz7xWrVAKDz0EU6fCmWfGTrbTNGQkIrIr1q2DBx4Iew+tWgXXXw89e8J++8VOtstUCCIiO8Md3ngjzBPMmwdnnx3mCapVi52s0DRkJCJSUNOmQaNG4XyC3XeHkSPh3//OiDIAFYKIyI4tXw5XXQXHHRfWETzwAHz2GTRuHDtZkdKQkYjItqxbB4MGQe/esHIlXH019OoFBxwQO1lSqBBERDbnHoaCOnYMO5GeeWbYkO7YY2MnSyoNGYmIbGrmzDAU9Je/hMfDh8OoURlfBqBCENm+Xr1iJ5Di8v33cO21UKNGONz+3nvDJPI554Sj7rKACkFke3r3jp1Akm39+jBJXLUqPPJIWGQ2d244xWyPPWKnK1aaQxCR7DVyZNh4bvZsaNgwXBVUrx47VTS6QhDZXK9eYYhg4zDBxs81fJQ5Zs8OC8rOPhvy8mDYMHjrrawuAwBz99gZCiwnJ8cnTZoUO4ZkE7Nwx4lkhh9+CMOAgwZBqVLQowdcd13GDw2Z2WR3z9nR6zRkJCKZLy8PHnssFMBPP8Fll4U9iA48MHaylKIhI5Ht6dkzdgIprDFjwgrjjXcQTZkSykFlsAUVgsj2aN4gfX3+OTRrFhaVrV4dzjAeOxZq1oydLGWpEEQks/z0U1hhXL06vPMO3HlnWGzWokXWrCfYVZpDEJHMsGEDPPEE3HprWGTWrh3ccQccdFDsZGlDVwgikv7Gjg0nll15JRxzDEyeHMpBZbBTVAgikr7mzQtDQWecAStWwJAhYZioVq3YydKSCkFE0s/PP0PnzuFqYMwY6NsXZs2Cli01T1AImkMQkfSxYQM8/TR07x4Ot7/kklAGBx8cO1lGUCGISHp4992w4dzUqVC3LowYASecEDtVRtGQkYikti+/hPPOg/r1w9YTL70E48erDJJAhSAiqWnFCujaFY4+OhxQc/vtYVO61q01T5AkGjISkdSSnw/PPgvdusGyZXDxxWGeoEKF2MkyngpBRFLH+PFhnmDKFDj55LAt9Yknxk6VNTRkJCLxffVVGAqqVy/cPZSbC++/rzIoZrpCEJF4Vq4Mew3dfTfstlvYTPDmm6FkydjJspIKQUSKX34+PPdcmDReuhTatIF+/aBSpdjJslq0ISMzq2Rm48xslpnNMLMbYmURkWL0wQdQp05YVFapUnj8/PMqgxQQcw4hD+jo7kcDdYBrzOyYiHkkE+j8gtS1cCFccEFYVLZ4cbhC+PDDMHksKSFaIbj7Unefkvh8BTAL0H1lUji9e8dOIJv75Zdw8ly1avD663DbbeHwmgsvDPMGkjJSYg7BzKoAtYCP4iYRkSKTnw8vvABduoQrgvPPDxPIlSvHTibbEL2ezaw0MBTo4O4/b+Xr7c1skplNWr58efEHlNTXq1dYubpx9erGzzV8FM+ECXDKKXDRRWHjuffegxdfVBmkOHP3eG9u9gdgODDa3Qfu6PU5OTk+adKk5AeT9GUGEb+ns96iReGKIDc3FEG/fqEUNDQUlZlNdvecHb0u2pCRmRnwJDCrIGUgIils1aqwlqB//7BFdffuoRhKl46dTHZCzDmEusBFwDQzm5p4rpu7j4iYSdJdz56xE2QX97D76C23wNdfQ6tWcNddUKVK7GSyC6IVgru/B2jLQilamjcoPhMnwg03hFtHjz8+DBP9+c+xU0khaGBPRHbOkiXQtm3YZ+jLL+HJJ+Hjj1UGGSAlbjsVkTSwejXcc0+YKM7LC3ME3bpBmTKxk0kRUSGIyPa5w5Ah4VD7BQvg3HNhwAA47LDYyaSIachIRLZt8uSwJXXr1rDvvjBuHAwdqjLIUCoEEdnS0qXQrh3Urg1z5sDgwaEc6tePnUySSENGIvKbNWvg3nvDkZVr10KnTmFNQdmysZNJMVAhiEiYJxg6NBxO89VX0Lx5WGh2xBGxk0kx0pCRSLabOhVOPz0sKitTBt5+O+xKqjLIOioEkWz1zTdw+eVhUdmMGfDoo+Fw+zPOiJ1MItGQkUi2WbsW7r8f7rgjrC248cZwRsG++8ZOJpGpEESyhXsYCurUKawwbto0LDQ78sjYySRF7HDIyMzqmlmpxOcXmtlAM9Om5iLp5LPPoGHDsKhs771h9Gh4802VgfxOQeYQHgFWmVlNoDOwAPhnUlOJSNH49lu44gqoVStMHj/0UPh45pmxk0kKKkgh5Hk4Rac5cL+73w9o8xKRVLZuXRgOqloVnnoKrrsO5s2Da66B3TVSLFtXkO+MFWbWFbgQqGdmJYA/JDeWiOwS9zAU1LFjKICzzw7FUK1a7GSSBgpyhdAaWAv83d2XARWAAUlNJSI7b/r0MBTUvHm4Chg5Ev79b5WBFNgOrxASJTBwk8cL0RyCSOr47jvo0QMeeyxsMfHAA3DllfAHXcjLztlmIZjZe+5+qpmtADY9tdwAd/d9kp5ORLZt/XoYNAh694YVK+Dqq8OJcQccEDuZpKltFoK7n5r4qAlkkVTiDiNGhHmCOXPCMNHAgXDssbGTSZoryDqEhlt5rm1y4ojIds2cCU2ahEVl7jB8OIwapTKQIlGQSeUeZvaImZUysz+a2ZvAX5IdTEQ28f33cP31UKMGTJgQtqieNg3OOQfMYqeTDFGQQjgN+AKYCrwHvODuLZOaSkSC9evhwQfDeoJBg6B9+3A7aYcOsMcesdNJhilIIewHnEQohbVAZTP9k0Qk6UaNgpo1w5XBCSfAp5/Cww9DuXKxk0mGKkghTABGuntjoDbwJ+D9pKYSyWZz5oShoCZNwhXCsGHw1ltQvXrsZJLhCrJSuWFi7QHuvhq43szqJTeWSBb68cdwC+mgQVCyZDix7LrrNDQkxaYgC9MWmtl+QFVgr+RHEskyeXnhEPsePUIpXHYZ3H47HHhg7GSSZXZYCGZ2GXADUJEwsVwH+BBokNxoIllgzJhwQM2MGVC/Ptx3X5g3EImgIHMINxDmDha4++lALWB5UlOJZLrPP4dmzcKistWr4dVXYexYlYFEVZBCWOPuawDMbE93nw0cldxYIhnqp5/CCuPq1eGdd+DOO8NisxYttJ5AoivIpPIiM9sXeB0YY2Y/AkuSG0skw2zYAE88AbfeGhaZtWsXzjQ+6KDYyUR+VZBJ5RaJT3uZ2TigLDAqqalEMsnYsWEh2bRpUK9emCeoVSt2KpEt7NTRSe7+brKCiGScefPg5pvDwfZVqsCQIXDeeRoakpRVkDkEEdkZP/8MnTvDMceEu4j69oVZs6BlS5WBpDQdripSVDZsgKefhu7dYflyuOQS6NMHDj44djKRAinI9tfXJhamici2vPsu5OTA5ZeHjegmTgyH26sMJI0UZMjoIGCimf3LzBprYzuRTcyfH+YF6teHH36Al16C8ePDZnQiaWaHheDutxK2rXgSuASYa2Z9zezwJGcTSV0rVkDXruEA+1GjwlYTs2dD69aaJ5C0VaBJZXd3YFniVx5hS+xXzOyuJGYTST35+WGe4Mgjw6Ky888Pq45vvRX23jt2OpFCKcgcwvVmNhm4i7Dt9f+5+1XACcB5hXnzxBDUHDObZ2ZdCvNniSTd+PFQu3ZYVHboofDRR/Dss1ChQuxkIkWiIHcZlQPOdfcFmz7p7vlm1nRX39jMSgCDgEbAIsI8xRvuPnNX/0yRpPjqq3Ab6ZAhULEi5ObCBRdoaEgyTkFWKvfYztdmFeK9TwTmufuXAGb2EtAcUCFIali5Evr1g3vugd12g169wkKzkiVjJxNJipjrECoAX2/yeBHhqE6RuPLz4bnnwqTx0qXwt7+F+YJKlWInE0mqmCuVt3a97Vu8yKy9mU0ys0nLl2vXbUmy99+Hk04Ki8oqVYIPPwxDRCoDyQIxC2ERsOnfsopsZRdVdx/s7jnunlO+fPliCydZZuHCMC9w6qmwZEm4QvjwQ6hTJ3YykWITsxAmAlXN7FAz2wM4H3gjYh7JRr/8Eo6uPOqosAndbbeF20gvvDDMG4hkkWhzCO6eZ2bXAqOBEsBT7j4jVh7JMvn58MIL0KULLF4crg7uvBMOOSR2MpFoom5u5+4jgBExM0gWmjAhnE/w0Udh/6GXX4a6dWOnEolO18SSPRYtCkNBJ58c5gyeeSaUgspABND215INVq2CAQOgf/8wVNS9exgqKl06djKRlKJCkMzlDi++CLfcEq4OWrWCu+4Kp5eJyBY0ZCSZaeLEMBTUpg2ULx/OK/jXv1QGItuhQpDMsmQJtG0LJ54IX34JTz4ZyqFevdjJRFKehowkM6xeHfYc6tcP8vLCHEG3blCmTOxkImlDhSDpzT3sQtq5MyxYAOeeGyaQDzssdjKRtKMhI0lfkyeHoaDWrWHffWHcOBg6VGUgsotUCJJ+li4Nh9TUrg1z5sDgwaEc6tePnUwkrWnISNLHmjVw773Qty+sXQudOoU1BWXLxk4mkhFUCJL63OHVV8PhNPPnQ/PmcPfdcMQRsZOJZBQNGUlq++QTOP10aNkSSpWCMWPCrqQqA5Eip0KQ1PTNN3D55XDCCTB9Ojz8cCiHhg1jJxPJWBoyktSydi3cfz/ccUdYW9ChQzijYL/9YicTyXgqBEkN7jBsWJgo/uILaNo0LDQ78sjYyUSyhoaMJL7PPgtDQS1awJ57wujR8OabKgORYqZCkHi+/RauuAJq1YKpU+HBB+HTT+HMM2MnE8lKGjKS4rduXfjh/49/hDONr70WevaE/fePnUwkq6kQpPi4w/Dh0LEjzJ0LjRvDwIFw9NGxk4kIGjKS4jJ9Opx1FjRrBiVKwIgRMHKkykAkhagQJLm++w6uuQZq1gznEtx3X5hEbtIkdjIR2YyGjCQ51q+HQYOgd29YsQKuuip8fsABsZOJyDaoEKRouYehoJtuCjuRNmoUNqQ79tjYyURkBzRkJEVn5swwFHTOOZCfH9YSjB6tMhBJEyoEKbwffoDrr4caNWDChHDn0PTpYbWxWex0IlJAGjKSXbd+PTz6aFhD8L//Qfv2YW1B+fKxk4nILlAhyK4ZNSrME8yaBQ0ahHmCGjVipxKRQtCQkeycOXPCUFCTJmHF8euvw9tvqwxEMoAKQQrmxx/hxhuhenUYPx4GDIAZM8LpZZonEMkIGjKS7cvLg8cfD2cS/PADXHYZ3H47/PGPsZOJSBHTFYJs29tvh51Ir746XBlMmQKDB6sMRDKUCkG2NHdu2HOoUaOwG+nQoTBuHBx3XOxkIpJEKgT5zf/+F04sO/bYUAD9+oXFZueeq3kCkSygOQSBDRvgySfh1lvDZnTt2oUzjQ86KHYyESlGukLIduPGwfHHh5PLqlWDSZPgiSdUBiJZSIWQrb74IgwFNWgAP/8MQ4bAu++GchCRrKRCyDY//wy33ALHHANvvQV9+oTVxi1bap5AJMtFmUMwswHAX4B1wBfApe7+U4wsWWPDBnj6aejePRxu37Yt9O0Lf/pT7GQikiJiXSGMAaq7ew3gc6BrpBzZ4b//hZwcuPxyqFo1nFz2zDMqAxH5nSiF4O5vuXte4uEEoGKMHBlv/nxo1QpOOy2sMn7ppbDtRE5O7GQikoJSYQ6hHTAydoiMsmIFdOsWDrAfMSJsST17NrRurXkCEdmmpM0hmNnbwNbuXezu7sMSr+kO5AG52/lz2gPtAQ455JAkJM0g+fnw7LOhDJYtg4suCovLKlSInUxE0kDSCsHdG27v62bWFmgKnOHuvp0/ZzAwGCAnJ2ebr8t648dDhw5hv6E6dcK21CedFDuViKSRKENGZtYYuAVo5u6rYmTIGAsWhKGgevXC3UPPPw8ffKAyEJGdFmvrioeAPYExFsa0J7j7lZGypKeVK6F/f7j77jAv0LMn3HwzlCoVO5mIpKkoheDuR8R434yQnx+uArp2hSVL4G9/gzvvhEqVYicTkTSXCncZSUF98EGYH2jbNkwUf/AB5OaqDESkSKgQ0sHXX4crgbp1YfFi+Oc/YcIEOPnk2MlEJINo++tU9ssvcNdd4fxi97A99S23QOnSsZOJSAZSIaSi/Hx48cXww3/x4nAXUf/+ULly7GQiksE0ZJRqPvoITjkFLrwwnEkwfnzYckJlICJJpkJIFYsXh5XFdeqEtQVPPw0ffwynnho7mYhkCQ0ZxbZqVVhL0L9/2KK6Wzfo0gXKlImdTESyjAohFnd4+WXo3DncRdSyZZhAPvTQ2MlEJEtpyCiGiRPDUNAFF0C5cuHoyiFDVAYiEpUKoTgtWQKXXAInngjz5oXD7CdODPsQiYhEpiGj4rB6NQwcGLaiXr8+3E7arRvss0/sZCIiv1IhJJN7GArq3DncOXTuuWGe4PDDYycTEdmChoySZcqUcHRl69ZQtiyMHQtDh6oMRCRlqRCK2rJl0K5dOLd49mx47LFQDqefHjuZiMh2acioqKxZA/fdB336wNq10LFj2HuobNnYyURECkSFUFju8Npr0KkTzJ8PzZqFhWZVq8ZOJiKyUzRkVBhTp0KDBnDeeeGksjFjYNgwlYGIpCUVwq745hto3x6OPx6mTYOHH4ZPPoGGDWMnExHZZRoy2hlr18IDD8Dtt4e1BR06wG23wX77xU4mIlJoKoSCcA9DQZ06wRdfwDnnwD33wFFHxU4mIlJkNGS0I9OmQaNG0KIF7LknjBoFw4erDEQk46gQtmX5crjqKjjuuDA/8OCD8OmncNZZsZOJiCSFhow2t24dPPQQ/OMfsHIlXHst9OwJ++8fO5mISFKpEDZyD0NBHTvC3LnQuHHYkO7oo2MnExEpFhoyApgxIwwFNWsGJUrAiBEwcqTKQESySnYXwvffhyGhmjXDuQT33QeffQZNmsROJiJS7LJzyGj9+rCYrFcvWLECrrwSeveGAw6InUxEJJrsK4SRI+Gmm8JOpI0awb33wrHHxk4lIhJd9gwZzZwZhoLOPhs2bIA334TRo1UGIiIJ2VEId9wBNWrAhx+GO4emT4emTcEsdjIRkZSRHUNGhx4Kl18e1haULx87jYhISsqOQmjTJvwSEZFtyo4hIxER2SEVgoiIACoEERFJUCGIiAigQhARkQQVgoiIACoEERFJUCGIiAgA5u6xMxSYmS0HFsTOkVAO+C52iB1QxsJL9XyQ+hlTPR9kfsbK7r7DbRrSqhBSiZlNcvec2Dm2RxkLL9XzQepnTPV8oIwbachIREQAFYKIiCSoEHbd4NgBCkAZCy/V80HqZ0z1fKCMgOYQREQkQVcIIiICqBCKhJl1MjM3s3Kxs2zOzAaY2Wwz+8zMXjOzfWNnAjCzxmY2x8zmmVmX2Hk2Z2aVzGycmc0ysxlmdkPsTFtjZiXM7BMzGx47y9aY2b5m9krie3CWmZ0cO9OmzOzGxP/f6Wb2opntlQKZnjKzb81s+ibP7W9mY8xsbuLjfsl4bxVCIZlZJaARsDB2lm0YA1R39xrA50DXyHkwsxLAIKAJcAxwgZkdEzfVFvKAju5+NFAHuCYFMwLcAMyKHWI77gdGuXs1oCYplNXMKgDXAznuXh0oAZwfNxUAzwCNN3uuC/Afd68K/CfxuMipEArvXqAzkJKTMe7+lrvnJR5OACrGzJNwIjDP3b9093XAS0DzyJl+x92XuvuUxOcrCD/IKsRN9XtmVhE4B3gidpatMbN9gHrAkwDuvs7df4qbagu7A3ub2e5ASWBJ5Dy4+3+BHzZ7ujnwbOLzZ4G/JuO9VQiFYGbNgMXu/mnsLAXUDhgZOwThB+vXmzxeRIr9sN2UmVUBagEfxU2yhfsI/xjJjx1kGw4DlgNPJ4a1njCzUrFDbeTui4G7CVf3S4H/uftbcVNt0x/dfSmEf6wABybjTVQIO2BmbyfGFzf/1RzoDvRI8YwbX9OdMAySGy/pr2wrz6XkFZaZlQaGAh3c/efYeTYys6bAt+4+OXaW7dgdOB54xN1rAb+QpKGOXZEYh28OHAr8CShlZhfGTRXX7rEDpDp3b7i1583s/wjfSJ+aGYShmClmdqK7LyvGiNvMuJGZtQWaAmd4atxnvAiotMnjiqTApfrmzOwPhDLIdfdXY+fZTF2gmZmdDewF7GNmz7t7Kv1AWwQscveNV1avkEKFADQE5rv7cgAzexU4BXg+aqqt+8bMDnb3pWZ2MPBtMt5EVwi7yN2nufuB7l7F3asQvvmPL+4y2BEzawzcAjRz91Wx8yRMBKqa2aFmtgdhIu+NyJl+x0LLPwnMcveBsfNszt27unvFxPfe+cDYFCsDEn8XvjazoxJPnQHMjBhpcwuBOmZWMvH/+wxSaNJ7M28AbROftwWGJeNNdIWQ+R4C9gTGJK5kJrj7lTEDuXuemV0LjCbc2fGUu8+ImWkr6gIXAdPMbGriuW7uPiJipnR0HZCbKP4vgUsj5/mVu39kZq8AUwjDqZ+QAiuWzexFoD5QzswWAT2BO4F/mdnfCUXWKinvnRojCCIiEpuGjEREBFAhiIhIggpBREQAFYKIiCSoEEREBFAhiBQLM/sgdgaRHdFtpyIiAugKQeR3zKx24uyIvcysVGKv/Opbed3rZjY58fX2iecqJ/arL2dmu5nZeDM7M/G1lYmPB5vZf81samK/qT8X73+hyLbpCkFkM2Z2B2F/oL0Je/H028pr9nf3H8xsb8JWHKe5+/dmdhlhL/uPgCPc/YrE61e6e2kz6wjs5e59EudClExsry0SnQpBZDOJbRYmAmuAU9x9w1Ze0wtokXhYBTjL3SckvjYaOAI4buMP+00KoR7wFGEDtdfdfermf7ZILBoyEtnS/kBpoAzhSuF3zKw+YafMk929JmEPnL0SXyvJb4cQld789yYOP6kHLAaeM7OLk5BfZJeoEES2NBi4jXB2RP+tfL0s8KO7rzKzaoQjNjfqn/h9PYDHN/+NZlaZcI7B44TdVI8v4uwiu0y7nYpsIvEv9jx3fyExxv+BmTVw97GbvGwUcKWZfQbMIRxNipmdBtQG6rr7BjM7z8wudfenN/m99YGbzWw9sBLQFYKkDM0hiIgIoCEjERFJUCGIiAigQhARkQQVgoiIACoEERFJUCGIiAigQhARkQQVgoiIAPD/nEHm8vBb0XUAAAAASUVORK5CYII=\n",
      "text/plain": [
       "<Figure size 432x288 with 1 Axes>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "def plotLineAndPoints(l1, l2, coef = None):\n",
    "    list1x = []\n",
    "    list1y = []\n",
    "    list2x = []\n",
    "    list2y = []\n",
    "    for i in range(len(l1)):\n",
    "        list1x.append(l1[i][0])\n",
    "        list1y.append(l1[i][1])\n",
    "    for i in range(len(l2)):\n",
    "        list2x.append(l2[i][0])\n",
    "        list2y.append(l2[i][1])  \n",
    "        \n",
    "    plt.plot(list2x,list2y, 'bo')\n",
    "    plt.plot(list1x,list1y, 'r+')\n",
    "    \n",
    "    if coef:\n",
    "       x = np.linspace(-5,10,100)\n",
    "       m = -int(coef[0]) * 1.0/int(coef[1])\n",
    "       c = -int(coef[2]) * 1.0/int(coef[1])\n",
    "       y = m * x + c\n",
    "       plt.plot(x, y, '-r', label='line_equation')\n",
    "       plt.xlabel('x axis')\n",
    "       plt.ylabel('y axis')\n",
    "    \n",
    "    plt.show()\n",
    "    \n",
    "    \n",
    "## Sample Test Cases (We will have many more)\n",
    "plotLineAndPoints([(1, 2), (2, 3)], [(3, 4), (4, 5)], (-1,2,2))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "colab_type": "text",
    "id": "xI3oSb5LScm7"
   },
   "source": [
    "### Part B"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "colab_type": "text",
    "id": "61TPqs_JTL2-"
   },
   "source": [
    "Euclidean distance between two points is defined as by equation (1) on this [Wikipedia page](https://en.wikipedia.org/wiki/Euclidean_distance).\n",
    "\n",
    "This first part is meant to be written using Markdown math in this cell (double-click it to see the area where you'll write the equation):\n",
    "  1. Your first task is to write down the Euclidean distance between two points that is defined as by equation (1) on this [Wikipedia page](https://en.wikipedia.org/wiki/Euclidean_distance). It should contain both lines of equation (1).\n",
    "  \n",
    "<!-- Write equation here -->\n",
    "\n",
    "The following parts have to be coded using Python:\n",
    "  2. Given a point $(x_1,y_1)$ and a radius $r_1$, randomly generate 10 points which lie within the given radius of the given point. The radius is calculated using Euclidean distance. Store them in list $l_1$.\n",
    "  3. Generate another list $l_2$ for a new point $(x_2, y_2)$ and radius $r_2$\n",
    "  4. Use the function written in part A to plot the above sets of points."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 164,
   "metadata": {
    "colab": {},
    "colab_type": "code",
    "id": "5bNLsyriTKQd"
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Euclidean Distance:  2.23606797749979\n"
     ]
    }
   ],
   "source": [
    "p = (1,2,3,4,5)\n",
    "q = (2,3,4,5,6)\n",
    "dist = 0\n",
    "for i in range(len(p)):\n",
    "    dist = dist + (p[i] - q[i])**2\n",
    "euc = math.sqrt(dist)\n",
    "print(\"Euclidean Distance: \",euc) \n",
    "    "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 165,
   "metadata": {
    "colab": {},
    "colab_type": "code",
    "id": "Fb6XnZM4ulEN"
   },
   "outputs": [
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 432x288 with 1 Axes>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "import math\n",
    "import random\n",
    "\n",
    "x1, y1 = 0, 0\n",
    "r1 = 10\n",
    "x2, y2 = 25, 25\n",
    "r2 = 15\n",
    "\n",
    "def rand_point(x1,y1,r1):\n",
    "    alpha = 2 * math.pi * random.random()\n",
    "    r = r1 * math.sqrt(random.random())\n",
    "    x = r * math.cos(alpha) + x1\n",
    "    y = r * math.sin(alpha) + y1\n",
    "    return (x,y)\n",
    "\n",
    "\n",
    "l1 = []\n",
    "l2 = []\n",
    "\n",
    "for i in range(0,10):\n",
    "    l1.append(rand_point(x1,y1,r1))\n",
    "    l2.append(rand_point(x2,y2,r2))\n",
    "    \n",
    "plotLineAndPoints(l1,l2)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "colab": {
   "collapsed_sections": [],
   "name": "P556-Assignment0-S19.ipynb",
   "provenance": [],
   "version": "0.3.2"
  },
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.6.5"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 1
}
